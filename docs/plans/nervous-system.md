# Nervous System: Event-Driven Architecture for Reachy Nova

## Overview

The Nervous System replaces Reachy Nova's ad-hoc callback wiring with a decoupled, event-driven architecture using MQTT as the message bus. Every subsystem publishes **pure data events** (what happened), and a centralized Nervous System service — running in its own Docker container — owns **all priority and urgency decisions**, using a configurable rules table plus a Nova 2 Lite LLM sub-agent as final judge.

The speech-to-speech pipeline (Nova Sonic) is **not touched** — only `inject_text()` calls are mediated through the Nervous System.

### Design Principles

1. **Events are pure data** — they carry `type`, `source`, `payload`, `timestamp`. No priority or urgency in the event itself.
2. **The Nervous System owns all priority/urgency decisions** — via a configurable rules table mapping `(source, type)` to baseline priority/urgency, plus the LLM sub-agent as final judge.
3. **Each component is responsible for its own events** — it publishes what happened, not how important it is.
4. **The Nervous System manages the queue and interruption** — it accumulates events, applies rules, consults the LLM, and decides inject/queue/ignore.

---

## 1. Event Model

Events are pure data. No priority, urgency, or decision metadata is included — that is the Nervous System's job.

```python
@dataclass
class NovaEvent:
    """Pure data event published by any subsystem."""
    event_id: str          # UUID, generated by publisher
    type: str              # e.g. "snap_detected", "vision_description", "slack_mention"
    source: str            # e.g. "tracking", "vision", "slack", "browser", "heartbeat"
    payload: dict          # source-specific data (free-form)
    timestamp: float       # time.time() at publication
```

### Example Events

```python
# Tracking snap
NovaEvent(
    event_id="a1b2c3",
    type="snap_detected",
    source="tracking",
    payload={"rms": 0.42, "target_yaw": 15.0},
    timestamp=1707900000.0,
)

# Vision description
NovaEvent(
    event_id="d4e5f6",
    type="vision_description",
    source="vision",
    payload={"description": "I see a person waving at me!", "frame_id": 42},
    timestamp=1707900001.0,
)

# Slack mention
NovaEvent(
    event_id="g7h8i9",
    type="slack_mention",
    source="slack",
    payload={"user": "ori", "text": "Hey Reachy, what's up?", "channel": "C123", "ts": "1707900002.000100"},
    timestamp=1707900002.0,
)

# Heartbeat tick
NovaEvent(
    event_id="j0k1l2",
    type="tick",
    source="heartbeat",
    payload={"interval": 60, "wall_clock": "2025-02-14T10:00:00Z"},
    timestamp=1707900060.0,
)
```

### Serialization

Events are serialized as JSON on MQTT:

```json
{
  "event_id": "a1b2c3",
  "type": "snap_detected",
  "source": "tracking",
  "payload": {"rms": 0.42, "target_yaw": 15.0},
  "timestamp": 1707900000.0
}
```

---

## 2. MQTT Topic Structure

```
nova/events/{source}/{type}     # All events published here
nova/inject                     # Nervous System → App: text to inject into Sonic
nova/state/{key}                # Shared state broadcasts (retained)
nova/heartbeat                  # Heartbeat ticks
```

### Topic Examples

| Publisher | Topic | Payload |
|-----------|-------|---------|
| Tracking | `nova/events/tracking/snap_detected` | `{event_id, type, source, payload: {rms, target_yaw}, timestamp}` |
| Tracking | `nova/events/tracking/person_detected` | `{..., payload: {bbox: [x1,y1,x2,y2]}}` |
| Tracking | `nova/events/tracking/person_lost` | `{..., payload: {}}` |
| Tracking | `nova/events/tracking/mode_changed` | `{..., payload: {from: "idle", to: "face"}}` |
| Vision | `nova/events/vision/vision_description` | `{..., payload: {description: "..."}}` |
| Vision | `nova/events/vision/analysis_started` | `{..., payload: {trigger: "event"}}` |
| Slack | `nova/events/slack/slack_message` | `{..., payload: {user, text, channel, ts}}` |
| Slack | `nova/events/slack/slack_mention` | `{..., payload: {user, text, channel, ts}}` |
| Slack | `nova/events/slack/slack_reaction` | `{..., payload: {user, emoji, channel, ts}}` |
| Browser | `nova/events/browser/task_started` | `{..., payload: {instruction, url}}` |
| Browser | `nova/events/browser/task_completed` | `{..., payload: {instruction, result, success}}` |
| Browser | `nova/events/browser/progress` | `{..., payload: {message}}` |
| Memory | `nova/events/memory/query_result` | `{..., payload: {query, result}}` |
| Memory | `nova/events/memory/store_result` | `{..., payload: {query, result}}` |
| Heartbeat | `nova/heartbeat` | `{..., type: "tick", payload: {interval, wall_clock}}` |
| App | `nova/state/voice` | `{"state": "listening"}` (retained) |
| App | `nova/state/mood` | `{"mood": "happy"}` (retained) |
| App | `nova/state/engagement` | `{"level": 0.5}` (retained) |
| Nervous System | `nova/inject` | `{"text": "...", "event_id": "...", "priority": "HIGH"}` |

### Subscription Patterns

| Subscriber | Pattern | Purpose |
|------------|---------|---------|
| Nervous System | `nova/events/#` | Receives all events for evaluation |
| Nervous System | `nova/state/#` | Tracks app state for context-aware decisions |
| App (main.py) | `nova/inject` | Receives inject commands → calls `sonic.inject_text()` |

### Retained Messages

State topics (`nova/state/#`) use MQTT retained messages so that late-joining subscribers (e.g. the Nervous System restarting) immediately receive the current state.

---

## 3. Docker Compose

Two containers: **Mosquitto** (MQTT broker) and **Nervous System** (event evaluator + heartbeat).

```yaml
# docker-compose.nervous-system.yml

version: "3.8"

services:
  mosquitto:
    image: eclipse-mosquitto:2
    container_name: nova-mosquitto
    ports:
      - "1883:1883"    # MQTT
      - "9001:9001"    # WebSocket (optional, for debugging)
    volumes:
      - ./config/mosquitto/mosquitto.conf:/mosquitto/config/mosquitto.conf
      - mosquitto-data:/mosquitto/data
      - mosquitto-log:/mosquitto/log
    restart: unless-stopped
    healthcheck:
      test: ["CMD", "mosquitto_sub", "-t", "$$SYS/#", "-C", "1", "-i", "healthcheck", "-W", "3"]
      interval: 30s
      timeout: 10s
      retries: 3

  nervous-system:
    build:
      context: .
      dockerfile: docker/nervous-system/Dockerfile
    container_name: nova-nervous-system
    depends_on:
      mosquitto:
        condition: service_healthy
    environment:
      - MQTT_BROKER=mosquitto
      - MQTT_PORT=1883
      - AWS_ACCESS_KEY_ID=${AWS_ACCESS_KEY_ID}
      - AWS_SECRET_ACCESS_KEY=${AWS_SECRET_ACCESS_KEY}
      - AWS_DEFAULT_REGION=${AWS_DEFAULT_REGION:-us-east-1}
      - RULES_CONFIG=/app/config/rules.yaml
      - HEARTBEAT_INTERVAL=${HEARTBEAT_INTERVAL:-60}
      - LLM_ENABLED=${LLM_ENABLED:-true}
    volumes:
      - ./config/nervous-system/rules.yaml:/app/config/rules.yaml
    restart: unless-stopped

volumes:
  mosquitto-data:
  mosquitto-log:
```

### Mosquitto Configuration

```conf
# config/mosquitto/mosquitto.conf
listener 1883
allow_anonymous true
persistence true
persistence_location /mosquitto/data/
log_dest stdout
log_type all

# Optional WebSocket listener for debugging
listener 9001
protocol websockets
```

### Nervous System Dockerfile

```dockerfile
# docker/nervous-system/Dockerfile
FROM python:3.12-slim

WORKDIR /app

COPY docker/nervous-system/requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

COPY docker/nervous-system/nervous_system.py .
COPY docker/nervous-system/heartbeat.py .
COPY config/nervous-system/rules.yaml /app/config/rules.yaml

CMD ["python", "nervous_system.py"]
```

```
# docker/nervous-system/requirements.txt
paho-mqtt>=2.0.0
boto3>=1.35.0
pyyaml>=6.0
```

---

## 4. Configurable Rules Table

The rules table maps `(source, type)` pairs to baseline priority and urgency. Rules are loaded from a YAML config file and can be updated without rebuilding.

### Priority Levels

| Level | Meaning |
|-------|---------|
| `CRITICAL` | Safety or system-integrity events (future use) |
| `HIGH` | Demands immediate attention |
| `NORMAL` | Standard events, evaluated in context |
| `LOW` | Background information, rarely interrupts |

### Urgency Levels

| Level | Meaning |
|-------|---------|
| `IMMEDIATE` | Inject now, even if speaking |
| `NOW` | Inject at next natural pause |
| `DEFERRABLE` | Queue for later, inject when idle |
| `BACKGROUND` | Log only, do not inject |

### Rules Configuration File

```yaml
# config/nervous-system/rules.yaml

# Default rule for unknown (source, type) pairs
default:
  priority: NORMAL
  urgency: DEFERRABLE
  llm_evaluate: true        # Consult LLM for final decision

# Rules keyed by (source, type)
rules:
  # --- Tracking events ---
  tracking/snap_detected:
    priority: HIGH
    urgency: IMMEDIATE
    llm_evaluate: false      # Always inject, no LLM needed
    inject_template: "[A sharp sound was detected nearby — look in that direction!]"

  tracking/person_detected:
    priority: NORMAL
    urgency: NOW
    llm_evaluate: true       # LLM decides: "person just appeared, worth mentioning?"
    inject_template: "[A person just appeared in your view.]"

  tracking/person_lost:
    priority: LOW
    urgency: DEFERRABLE
    llm_evaluate: false
    inject_template: "[The person you were looking at has left.]"

  tracking/mode_changed:
    priority: LOW
    urgency: BACKGROUND
    llm_evaluate: false

  # --- Vision events ---
  vision/vision_description:
    priority: NORMAL
    urgency: NOW
    llm_evaluate: true
    inject_template: "[Your camera sees: {description}] React to what you see briefly."

  vision/analysis_started:
    priority: LOW
    urgency: BACKGROUND
    llm_evaluate: false

  # --- Slack events ---
  slack/slack_mention:
    priority: HIGH
    urgency: IMMEDIATE
    llm_evaluate: false
    inject_template: "[You were mentioned on Slack by {user}: {text}] Briefly acknowledge this."

  slack/slack_message:
    priority: NORMAL
    urgency: NOW
    llm_evaluate: true       # LLM decides based on content + engagement level
    inject_template: "[Slack message from {user}: {text}]"

  slack/slack_reaction:
    priority: LOW
    urgency: BACKGROUND
    llm_evaluate: false

  # --- Browser events ---
  browser/task_completed:
    priority: NORMAL
    urgency: NOW
    llm_evaluate: false
    inject_template: "[Browser task result: {result}]"

  browser/progress:
    priority: LOW
    urgency: DEFERRABLE
    llm_evaluate: false
    inject_template: "[Browser status: {message}]"

  browser/task_started:
    priority: LOW
    urgency: BACKGROUND
    llm_evaluate: false

  # --- Memory events ---
  memory/query_result:
    priority: NORMAL
    urgency: NOW
    llm_evaluate: false
    inject_template: "[Memory recall: {result}]"

  memory/store_result:
    priority: LOW
    urgency: BACKGROUND
    llm_evaluate: false

  # --- Heartbeat ---
  heartbeat/tick:
    priority: LOW
    urgency: BACKGROUND
    llm_evaluate: false

  # --- Future: Discord ---
  # discord/discord_mention:
  #   priority: HIGH
  #   urgency: IMMEDIATE
  #   llm_evaluate: false
  #   inject_template: "[Discord mention from {user}: {text}]"
```

### Rule Resolution

```
1. Look up exact (source, type) key → "tracking/snap_detected"
2. If not found, look up wildcard source → "tracking/*"
3. If not found, use default rule
4. Apply baseline priority + urgency
5. If llm_evaluate: true, pass to LLM sub-agent for final decision
6. If llm_evaluate: false, execute decision directly based on urgency
```

---

## 5. LLM Sub-Agent

The Nervous System uses Amazon Nova 2 Lite (`us.amazon.nova-2-lite-v1:0`) as a sub-agent to evaluate ambiguous events. The LLM receives **accumulated context** — recent events, current app state, and the new event — and decides whether to inject, queue, or ignore.

### When the LLM is Consulted

The LLM is only called when a rule has `llm_evaluate: true`. This avoids unnecessary API calls for clear-cut cases (snaps always inject, reactions always ignore).

### LLM Prompt

```python
LLM_PROMPT_TEMPLATE = """You are the interrupt evaluator for a social robot called Reachy Mini.
The robot is currently in a voice conversation with a human.

Current robot state:
- Voice: {voice_state}
- Mood: {mood}
- Engagement level: {engagement_level}/1.0
- Time since last inject: {seconds_since_last_inject}s

Recent event history (last {event_window_size}):
{recent_events_summary}

New event to evaluate:
- Source: {source}
- Type: {type}
- Baseline priority: {priority}
- Baseline urgency: {urgency}
- Content: {payload_summary}

Given everything above, should this event interrupt the current conversation?

Rules:
- INJECT: Important enough to break into the conversation now
- QUEUE: Worth mentioning, but wait for a pause or idle moment
- IGNORE: Not worth mentioning at all

Reply with exactly one word: INJECT, QUEUE, or IGNORE."""
```

### LLM Call

```python
async def llm_evaluate(self, event: NovaEvent, rule: Rule, context: dict) -> str:
    """Ask Nova 2 Lite for a final interrupt decision."""
    prompt = LLM_PROMPT_TEMPLATE.format(
        voice_state=context["voice_state"],
        mood=context["mood"],
        engagement_level=context["engagement_level"],
        seconds_since_last_inject=context["seconds_since_last_inject"],
        event_window_size=len(context["recent_events"]),
        recent_events_summary=self._format_recent_events(context["recent_events"]),
        source=event.source,
        type=event.type,
        priority=rule.priority,
        urgency=rule.urgency,
        payload_summary=json.dumps(event.payload)[:500],
    )

    body = {
        "messages": [{"role": "user", "content": [{"text": prompt}]}],
        "inferenceConfig": {"maxTokens": 10, "temperature": 0.1, "topP": 0.9},
    }
    response = self.bedrock_client.invoke_model(
        modelId="us.amazon.nova-2-lite-v1:0",
        body=json.dumps(body),
    )
    result = json.loads(response["body"].read())
    answer = result["output"]["message"]["content"][0]["text"].strip().upper()

    if "INJECT" in answer:
        return "inject"
    elif "IGNORE" in answer:
        return "ignore"
    return "queue"
```

### LLM Fallback

If the LLM call fails (network error, timeout, etc.), the Nervous System falls back to the baseline urgency from the rules table:
- `IMMEDIATE` / `NOW` → inject
- `DEFERRABLE` → queue
- `BACKGROUND` → ignore

---

## 6. Heartbeat

The Heartbeat runs inside the Nervous System container as a background thread. It publishes periodic time-based events to MQTT, enabling time-aware behaviors (e.g. "it's been 5 minutes since anyone spoke, say something").

### Heartbeat Implementation

```python
class Heartbeat:
    """Publishes periodic time events to MQTT."""

    def __init__(self, mqtt_client, interval: int = 60):
        self.client = mqtt_client
        self.interval = interval
        self._thread = None

    def start(self, stop_event: threading.Event):
        def _run():
            tick_count = 0
            while not stop_event.is_set():
                stop_event.wait(timeout=self.interval)
                if stop_event.is_set():
                    break
                tick_count += 1
                event = {
                    "event_id": str(uuid.uuid4()),
                    "type": "tick",
                    "source": "heartbeat",
                    "payload": {
                        "interval": self.interval,
                        "tick_count": tick_count,
                        "wall_clock": datetime.utcnow().isoformat() + "Z",
                    },
                    "timestamp": time.time(),
                }
                self.client.publish(
                    "nova/heartbeat",
                    json.dumps(event),
                )

        self._thread = threading.Thread(target=_run, daemon=True, name="heartbeat")
        self._thread.start()
```

### Heartbeat Uses

- **Idle prompts**: After N ticks with no events, the Nervous System can inject a "say something" prompt
- **Scheduled behaviors**: "Every 5 minutes, check Slack for queued messages"
- **Health monitoring**: If heartbeat stops arriving, the app knows the Nervous System container is down
- **Time context**: The LLM sub-agent can see "it's been 3 minutes since the last event" when evaluating

---

## 7. Main App Integration

### Publishing Events (Subsystems → MQTT)

Each subsystem gets a lightweight MQTT publishing helper. The existing callback wiring stays for local effects (head tracking, audio output) — MQTT is added alongside for the Nervous System.

```python
# In main.py — MQTT publisher setup
import paho.mqtt.client as mqtt
import json
import uuid
import time

mqtt_client = mqtt.Client(client_id="reachy-nova-app")
mqtt_client.connect(os.environ.get("MQTT_BROKER", "localhost"), 1883)
mqtt_client.loop_start()

def publish_event(source: str, event_type: str, payload: dict):
    """Publish a pure data event to MQTT."""
    event = {
        "event_id": str(uuid.uuid4()),
        "type": event_type,
        "source": source,
        "payload": payload,
        "timestamp": time.time(),
    }
    topic = f"nova/events/{source}/{event_type}"
    mqtt_client.publish(topic, json.dumps(event))

def publish_state(key: str, value: dict):
    """Publish retained state to MQTT."""
    mqtt_client.publish(f"nova/state/{key}", json.dumps(value), retain=True)
```

### Where Events Are Published

Current callback sites in `main.py` add a `publish_event()` call alongside their existing logic:

```python
# Tracking events — tracking.py fires on_event, main.py wires it:
def on_tracking_event(event_type: str, data: dict):
    # Existing: local vision trigger
    if event_type in ("person_detected", "snap_detected", "mode_changed"):
        vision.trigger_analyze()
    # New: publish to MQTT
    publish_event("tracking", event_type, data)

# Vision description — existing callback:
def on_vision_description(desc: str):
    update_state(vision_description=desc, vision_analyzing=False, mood="excited")
    # REMOVE direct sonic.inject_text() call — Nervous System handles this now
    # Instead, publish the event:
    publish_event("vision", "vision_description", {"description": desc})

# Slack events — existing callback:
def on_slack_event(event: SlackEvent):
    summary = f"[{event.user}] {event.text[:80]}"
    update_state(slack_last_event=summary)
    # Publish to MQTT (Nervous System replaces InterruptGate)
    publish_event("slack", f"slack_{event.type}", {
        "user": event.user,
        "text": event.text,
        "channel": event.channel,
        "ts": event.ts,
        "is_mention": event.is_mention,
        "is_dm": event.is_dm,
    })

# Browser progress — existing callback:
def on_browser_progress(message: str):
    # REMOVE direct sonic.inject_text() — Nervous System handles this
    publish_event("browser", "progress", {"message": message})

# Voice state — publish for Nervous System context:
def on_voice_state(state: str):
    update_state(voice_state=state)
    publish_state("voice", {"state": state})

# Mood changes:
def update_state(**kwargs):
    with state_lock:
        app_state.update(kwargs)
        if "mood" in kwargs:
            publish_state("mood", {"mood": kwargs["mood"]})
        if "voice_state" in kwargs:
            publish_state("voice", {"state": kwargs["voice_state"]})
```

### Subscribing to Inject Commands (MQTT → Sonic)

The app subscribes to `nova/inject` and calls `sonic.inject_text()`:

```python
def on_inject_message(client, userdata, msg):
    """Handle inject commands from the Nervous System."""
    try:
        data = json.loads(msg.payload.decode())
        text = data.get("text", "")
        if text:
            sonic.inject_text(text)
            logger.info(f"[Nervous System] Injected: {text[:80]}")
    except Exception as e:
        logger.warning(f"Inject message error: {e}")

mqtt_client.subscribe("nova/inject")
mqtt_client.on_message = on_inject_message
```

### What Gets Removed

With the Nervous System handling interrupt decisions:

1. **`InterruptGate` class in `nova_slack.py`** — no longer needed; the Nervous System replaces it
2. **Direct `sonic.inject_text()` calls** in `on_vision_description`, `on_browser_progress`, `on_slack_interrupt` — replaced by MQTT publish; the Nervous System decides whether/when to inject
3. **`slack_bot.update_context()` call** in the main loop — replaced by `publish_state("voice", ...)` which the Nervous System reads

### What Stays Unchanged

1. **Nova Sonic bidirectional stream** — audio in/out, tool use, transcripts
2. **Local head tracking** — tracking.py still drives head motion directly
3. **Skill executors** — tool_use still runs skills synchronously
4. **Audio pipeline** — mic → Sonic → speaker
5. **Camera pipeline** — frame → vision/tracking (local processing unchanged)

### Graceful Degradation

If MQTT is unavailable (no Docker, network issue), the app falls back to direct callbacks — the existing behavior. This is checked at startup:

```python
mqtt_available = False
try:
    mqtt_client = mqtt.Client(client_id="reachy-nova-app")
    mqtt_client.connect(os.environ.get("MQTT_BROKER", "localhost"), 1883, keepalive=5)
    mqtt_client.loop_start()
    mqtt_available = True
    logger.info("MQTT connected — Nervous System integration active")
except Exception:
    logger.warning("MQTT not available — falling back to direct callbacks")

def publish_event(source, event_type, payload):
    if mqtt_available:
        # ... publish to MQTT
    # else: no-op, local callbacks handle it
```

---

## 8. Priority Matrix

Complete table of all known event types with their baseline rules:

| Source | Type | Priority | Urgency | LLM? | Inject Template |
|--------|------|----------|---------|------|-----------------|
| tracking | snap_detected | HIGH | IMMEDIATE | No | `[A sharp sound was detected nearby!]` |
| tracking | person_detected | NORMAL | NOW | Yes | `[A person just appeared in your view.]` |
| tracking | person_lost | LOW | DEFERRABLE | No | `[The person you were looking at has left.]` |
| tracking | mode_changed | LOW | BACKGROUND | No | *(none — log only)* |
| vision | vision_description | NORMAL | NOW | Yes | `[Your camera sees: {description}]` |
| vision | analysis_started | LOW | BACKGROUND | No | *(none)* |
| slack | slack_mention | HIGH | IMMEDIATE | No | `[Slack mention from {user}: {text}]` |
| slack | slack_message | NORMAL | NOW | Yes | `[Slack message from {user}: {text}]` |
| slack | slack_reaction | LOW | BACKGROUND | No | *(none)* |
| browser | task_completed | NORMAL | NOW | No | `[Browser result: {result}]` |
| browser | progress | LOW | DEFERRABLE | No | `[Browser status: {message}]` |
| browser | task_started | LOW | BACKGROUND | No | *(none)* |
| memory | query_result | NORMAL | NOW | No | `[Memory recall: {result}]` |
| memory | store_result | LOW | BACKGROUND | No | *(none)* |
| heartbeat | tick | LOW | BACKGROUND | No | *(none)* |

---

## 9. Nervous System Core Logic

### Event Processing Pipeline

```
Event arrives on nova/events/#
        │
        ▼
┌─────────────────┐
│  Rule Lookup     │ ← rules.yaml
│  (source/type)   │
└────────┬────────┘
         │
         ▼
┌─────────────────┐     ┌────────────────┐
│  llm_evaluate?  │─Yes→│  Nova 2 Lite   │
│                 │     │  Sub-Agent      │
└────────┬────────┘     └───────┬────────┘
         │ No                    │
         ▼                       ▼
┌─────────────────┐     Decision: inject/queue/ignore
│  Apply urgency  │◄────────────┘
│  directly       │
└────────┬────────┘
         │
         ▼
┌─────────────────────────────────┐
│  IMMEDIATE → publish nova/inject│
│  NOW       → publish nova/inject│
│  DEFERRABLE → add to queue      │
│  BACKGROUND → log only          │
└────────┬────────────────────────┘
         │
         ▼
┌─────────────────────────────────┐
│  Queue drain: when voice=idle   │
│  and engagement < 0.3, inject   │
│  oldest queued event            │
└─────────────────────────────────┘
```

### Queue Manager

The Nervous System maintains an internal priority queue of deferred events:

```python
class QueueManager:
    """Manages deferred events, draining them when the robot is idle."""

    def __init__(self, mqtt_client, max_size=50):
        self.client = mqtt_client
        self.queue: deque[tuple[str, NovaEvent, Rule]] = deque(maxlen=max_size)
        self._voice_state = "idle"
        self._engagement = 0.0

    def enqueue(self, event: NovaEvent, rule: Rule):
        self.queue.append((rule.priority, event, rule))

    def update_state(self, voice_state: str, engagement: float):
        self._voice_state = voice_state
        self._engagement = engagement
        # Drain queue when idle
        if voice_state == "idle" and engagement < 0.3 and self.queue:
            self._drain_one()

    def _drain_one(self):
        if not self.queue:
            return
        _, event, rule = self.queue.popleft()
        text = rule.render_template(event.payload)
        self.client.publish("nova/inject", json.dumps({
            "text": text,
            "event_id": event.event_id,
            "priority": rule.priority,
        }))
```

---

## 10. Future Extensions

Adding a new event source (e.g. Discord, email, calendar, home automation) requires only:

1. **Publish events** from the new service to `nova/events/{source}/{type}`
2. **Add rules** to `config/nervous-system/rules.yaml`:
   ```yaml
   discord/discord_mention:
     priority: HIGH
     urgency: IMMEDIATE
     llm_evaluate: false
     inject_template: "[Discord mention from {user}: {text}]"
   ```
3. **No code changes** to the Nervous System — it discovers new event types via wildcard subscription and falls back to the default rule if no specific rule exists.

### Potential Future Event Sources

| Source | Events | Notes |
|--------|--------|-------|
| Discord | `discord_mention`, `discord_message`, `discord_reaction` | Same pattern as Slack |
| Calendar | `event_starting`, `event_reminder` | Google Calendar / iCal integration |
| Email | `email_received`, `email_urgent` | Gmail / IMAP integration |
| Home | `motion_detected`, `doorbell`, `temperature_alert` | Home Assistant / MQTT bridge |
| System | `low_battery`, `high_cpu`, `disk_full` | Robot system monitoring |
| Weather | `weather_alert`, `forecast_update` | External API polling |

### Extending the Heartbeat

The heartbeat can be enhanced with scheduled behaviors by adding a schedule config:

```yaml
# Future: config/nervous-system/schedules.yaml
schedules:
  - name: "Check Slack queue"
    interval: 300  # every 5 minutes
    event_type: "check_slack_queue"
    source: "scheduler"
  - name: "Weather update"
    interval: 3600  # every hour
    event_type: "weather_check"
    source: "scheduler"
```

---

## Architecture Diagram

```
┌───────────────────────────────────────────────────────────┐
│                    Reachy Nova App                         │
│                                                           │
│  ┌──────────┐  ┌──────────┐  ┌──────────┐  ┌──────────┐ │
│  │ Tracking │  │  Vision  │  │  Slack   │  │ Browser  │ │
│  │          │  │          │  │          │  │          │ │
│  │ snap     │  │ describe │  │ message  │  │ progress │ │
│  │ person   │  │ analyze  │  │ mention  │  │ complete │ │
│  │ mode     │  │          │  │ reaction │  │          │ │
│  └────┬─────┘  └────┬─────┘  └────┬─────┘  └────┬─────┘ │
│       │              │              │              │       │
│       └──────────────┴──────────────┴──────────────┘       │
│                          │ publish_event()                  │
│                          ▼                                  │
│                   paho-mqtt client                          │
│                          │                                  │
│  ┌───────────────────────┼──────────────────────────────┐  │
│  │ subscribe nova/inject │                              │  │
│  │         │             │                              │  │
│  │         ▼             │                              │  │
│  │  sonic.inject_text()  │                              │  │
│  │                       │                              │  │
│  │  ┌──────────────┐     │   ┌──────────┐              │  │
│  │  │  Nova Sonic  │◄────┼───│   Mic    │              │  │
│  │  │  (voice)     │─────┼──►│ Speaker  │              │  │
│  │  └──────────────┘     │   └──────────┘              │  │
│  │   (speech-to-speech   │                              │  │
│  │    pipeline untouched)│                              │  │
│  └───────────────────────┼──────────────────────────────┘  │
│                          │                                  │
└──────────────────────────┼──────────────────────────────────┘
                           │
                    MQTT (port 1883)
                           │
┌──────────────────────────┼──────────────────────────────────┐
│            Docker: Nervous System                           │
│                          │                                  │
│  ┌───────────────────────┼──────────────────────────────┐  │
│  │              Mosquitto Broker                        │  │
│  │         nova/events/#    nova/inject                  │  │
│  │         nova/state/#     nova/heartbeat               │  │
│  └───────────────────────┼──────────────────────────────┘  │
│                          │                                  │
│  ┌───────────────────────┼──────────────────────────────┐  │
│  │          Nervous System Service                      │  │
│  │                       │                              │  │
│  │  ┌─────────────┐  ┌──┴────────┐  ┌──────────────┐  │  │
│  │  │ Rules Table │  │  Event    │  │  LLM         │  │  │
│  │  │ (YAML)     │  │  Accum.   │  │  Sub-Agent   │  │  │
│  │  │            │  │           │  │  (Nova 2     │  │  │
│  │  │ (src,type) │──│  Recent   │──│   Lite)      │  │  │
│  │  │  → pri/urg │  │  events   │  │              │  │  │
│  │  └─────────────┘  └──────────┘  └──────────────┘  │  │
│  │                                                    │  │
│  │  ┌─────────────┐  ┌──────────────┐                │  │
│  │  │  Queue      │  │  Heartbeat   │                │  │
│  │  │  Manager    │  │  (ticks)     │                │  │
│  │  │  (deferred) │  │              │                │  │
│  │  └─────────────┘  └──────────────┘                │  │
│  └──────────────────────────────────────────────────────┘  │
│                                                            │
└────────────────────────────────────────────────────────────┘
```

---

## Migration Path

### Phase 1: Add MQTT Publishing (Non-Breaking)

- Add `paho-mqtt` to `pyproject.toml`
- Add `publish_event()` / `publish_state()` helpers to `main.py`
- Add MQTT publish calls **alongside** existing callbacks (dual-write)
- Start `docker-compose.nervous-system.yml` with Mosquitto only
- Verify events flow via `mosquitto_sub -t "nova/events/#" -v`

### Phase 2: Deploy Nervous System Container

- Build and start the Nervous System container
- Verify it receives events and applies rules
- Verify `nova/inject` messages arrive at the app
- Both paths active: direct callbacks + MQTT inject (may produce duplicates)

### Phase 3: Cut Over

- Remove direct `sonic.inject_text()` calls from vision/slack/browser callbacks
- Remove `InterruptGate` from `nova_slack.py`
- Remove `slack_bot.update_context()` from main loop (replaced by `publish_state`)
- All inject decisions now flow through the Nervous System
- Keep local callbacks for non-inject effects (head tracking, state updates, etc.)

### Phase 4: Optimize

- Tune rules priorities/urgencies based on real usage
- Tune LLM prompts for better interrupt decisions
- Add new event sources (Discord, calendar, etc.)
- Add heartbeat-driven scheduled behaviors
